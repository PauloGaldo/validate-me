(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{174:function(e,t,a){"use strict";a.r(t);var s=a(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"main-diferences-between-other-solutions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#main-diferences-between-other-solutions","aria-hidden":"true"}},[e._v("#")]),e._v(" Main diferences between other solutions")]),e._v(" "),a("h3",{attrs:{id:"validate-me-lazy-loads-everything"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validate-me-lazy-loads-everything","aria-hidden":"true"}},[e._v("#")]),e._v(" Validate-me lazy loads everything")]),e._v(" "),a("p",[e._v("Rules and messages won't be loaded until are required.")]),e._v(" "),a("h3",{attrs:{id:"rehidrates-failed-rules-from-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rehidrates-failed-rules-from-server","aria-hidden":"true"}},[e._v("#")]),e._v(" Rehidrates failed rules from server")]),e._v(" "),a("p",[e._v("Validate-me can process an error sent by the server and instanciate the failed rules dynamically. This even makes possible to avoid configuring rules by hand in each input and let the server (in the first submit) return the failed rules.")]),e._v(" "),a("p",[e._v("This also eases the validation process between client and server. In a full stack JS environment, it makes possible to reuse the same validation functions in both sides.")]),e._v(" "),a("h3",{attrs:{id:"warnings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#warnings","aria-hidden":"true"}},[e._v("#")]),e._v(" Warnings")]),e._v(" "),a("p",[e._v("Unknown rules (e.g. server-side only rules) are rendered as warning messages so the user can pay attention before submitting the form. They don't prevent submitting, they are only informative.")])])}],!1,null,null,null);r.options.__file="README.md";t.default=r.exports}}]);